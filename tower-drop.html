<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>המשחק שלי - Helix Jump</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #2c3e50;
            font-family: Arial, sans-serif;
            color: #fff;
            overflow: hidden;
        }
        canvas {
            display: block;
            border: 5px solid #ecf0f1;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
            max-height: 90vh;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
</head>
<body>
    <script>
        /**
         * The main p5.js sketch for the refactored Helix Jump game.
         * This code is structured with modern JavaScript practices for better readability and maintenance.
         */
        new p5(function(s) {

            // --- Constants and Configuration ---
            const SCENES = {
                MENU: 0,
                PLAY: 1,
                LEADERBOARD: 2,
                CREDITS: 3
            };
            let currentScene = SCENES.MENU;

            const CONFIG = {
                canvasWidth: 400,
                canvasHeight: 600,
                fonts: ["Arial", "Impact", "Arial Black"],
                palettes: [
                    [s.color(255, 255, 255), s.color(249, 241, 219), s.color(252, 213, 129), s.color(213, 41, 65), s.color(153, 13, 53)],
                    [s.color(248, 244, 227), s.color(255, 137, 102), s.color(42, 43, 42), s.color(112, 108, 157), s.color(229, 68, 109)],
                    [s.color(255, 228, 250), s.color(225, 218, 189), s.color(71, 99, 152), s.color(141, 200, 178), s.color(255, 196, 35)],
                    [s.color(249, 234, 225), s.color(19, 190, 156), s.color(170, 153, 143), s.color(204, 139, 134), s.color(125, 79, 80)],
                    [s.color(228, 214, 167), s.color(200, 130, 196), s.color(28, 17, 10), s.color(80, 162, 167), s.color(155, 41, 21)],
                    [s.color(165, 196, 212), s.color(123, 109, 141), s.color(73, 59, 42), s.color(132, 153, 177), s.color(89, 63, 98)],
                    [s.color(255, 238, 242), s.color(255, 200, 251), s.color(89, 87, 88), s.color(185, 188, 223), s.color(255, 146, 194)],
                    [s.color(255, 253, 253), s.color(240, 225, 0), s.color(11, 60, 73), s.color(183, 190, 188), s.color(125, 35, 109)],
                    [s.color(203, 121, 58), s.color(154, 3, 30), s.color(50, 19, 37), s.color(95, 15, 64), s.color(252, 220, 77)],
                    [s.color(178, 221, 247), s.color(76, 181, 174), s.color(100, 180, 200), s.color(202, 186, 200), s.color(255, 32, 62)],
                    [s.color(178, 221, 247), s.color(48, 107, 172), s.color(20, 27, 65), s.color(11, 156, 235), s.color(145, 142, 244)],
                    [s.color(232, 233, 243), s.color(177, 229, 242), s.color(39, 38, 53), s.color(166, 166, 168), s.color(200, 200, 200)],
                    [s.color(247, 255, 221), s.color(219, 161, 89), s.color(232, 233, 155), s.color(239, 200, 128), s.color(208, 227, 204)],
                    [s.color(0, 117, 196), s.color(214, 81, 8), s.color(239, 160, 11), s.color(239, 160, 11), s.color(89, 31, 10)],
                    [s.color(240, 231, 216), s.color(166, 58, 80), s.color(177, 155, 150), s.color(186, 110, 110), s.color(201, 223, 74)],
                    [s.color(246, 216, 174), s.color(244, 211, 94), s.color(46, 64, 87), s.color(8, 61, 119), s.color(218, 65, 103)],
                    [s.color(241, 242, 235), s.color(86, 98, 70), s.color(74, 74, 72), s.color(164, 194, 165), s.color(216, 218, 211)],
                    [s.color(255, 194, 226), s.color(110, 68, 255), s.color(184, 146, 255), s.color(255, 144, 179), s.color(239, 122, 133)],
                    [s.color(228, 223, 218), s.color(115, 29, 216), s.color(193, 102, 107), s.color(72, 169, 166), s.color(212, 180, 131)],
                    [s.color(239, 214, 172), s.color(67, 37, 52), s.color(40, 61, 101), s.color(54, 88, 85), s.color(196, 73, 0)],
                    [s.color(145, 245, 173), s.color(116, 82, 150), s.color(99, 42, 80), s.color(139, 158, 183), s.color(194, 232, 18)],
                    [s.color(212, 228, 188), s.color(150, 172, 183), s.color(72, 35, 60), s.color(54, 85, 143), s.color(64, 55, 110)],
                    [s.color(161, 204, 165), s.color(65, 93, 67), s.color(17, 29, 19), s.color(112, 151, 117), s.color(143, 155, 190)],
                    [s.color(213, 230, 141), s.color(107, 5, 4), s.color(36, 16, 35), s.color(163, 50, 11), s.color(71, 160, 37)],
                    [s.color(251, 251, 249), s.color(166, 52, 70), s.color(0, 0, 4), s.color(126, 25, 70), s.color(12, 98, 145)],
                ],
                titles: [
                    ["Endless", 0], ["Play", 0], ["Leaderboard", 0], ["Credits", 0]
                ]
            };

            // --- Game State Variables ---
            let Cur_Pal = 2;
            let keys = {};
            let layers = [];
            let ptsEarned = [];
            let previousMouseX = 0;
            let lastTouchX = 0;

            // --- Color Variables for smooth transitions ---
            let central, platform, bg, ball, lava;
            let targetCentral, targetPlatform, targetBg, targetBall, targetLava;

            // --- Game Over Animation Variables ---
            let particles = [];
            let explosionParticles = [];
            let screenFlashAlpha = 0;
            let shakeAmount = 0;
            let isGameOverAnimating = false;

            // --- Data for Leaderboard ---
            let leaderboard = [
                ["Arrowhead Co.", 13649], ["Ethan Botha", 2324], ["🐧 MrPenguin2 🐧", 4401],
                ["Dancing Doggle", 5599], ["Tsunamon", 1200], ["noahware", 74655],
                ["Clayton", 46587], ["Kochendorfer,Zachary", 20134], ["chris316213", 2326],
                ["Star Traveler", 5039], ["Lightning McCode", 2267], ["Thanksbeardgod", 3789],
                ["CHRISTIAN SCHOOL TRY HARD", 7160], ["WWescoat", 5128], ["DavidJAllen", 3821],
                ["MaxWhitten", 3338], ["20khagerty", 11169], ["megamanwhiz", 13124],
                ["ASSASSIN", 61723], ["Gray Strickland", 4898], ["raff", 5395],
                ["20khagerty", 108821], ["PriSSSSM", 4456], ["Matias M", 11904],
                ["HaZard_Luke", 27777], ["Caleb Taylor", 15028], ["Maria Alex", 23588],
                ["Ellie Sexton", 13232], ["GrantGoins", 46588], ["Brady Beard", 1929],
                ["iHack", 2145], ["timestruck", 1827], ["PanGalacticGargleBlaster", 6197],
                ["Nalin Theodore", 2072], ["Programster", 29080], ["Imgbrentlinger", 5718],
                ["Akiva Rosenberg", 65583], ["HoneyBadger1015", 61456], ["Jcofield.o", 17115],
                ["Bowtieman", 72190], ["Dylan721668", 6694], ["Computer?", 125670],
                ["Salamander Maniacs YT", 65576], ["Nikyan", 33740], ["braxtonbailey", 65386],
                ["The#1Pr🥔grammer", 88321], ["big sad", 62055], ["Austin", 43236],
                ["WWescoat", 9325], ["manny benitez", 5559], ["Robert McKenzie", 19898],
                ["Flagilament", 7824], ["angel.cruz", 40198], ["ACAlfredo", 1544],
                ["Devion Rennier", 6113], ["Declan Ross", 559], ["Andrew Karr", 3611],
                ["cool guy 24", 6552], ["misaboo918", 14925], ["bcruse12", 4880],
                ["xxxtentacion", 14891], ["Lampony Snicket", 5000], ["Aidan", 4276],
                ["Ethan Lee", 20937], ["Noah", 7785], ["siddadi1819", 4222],
                ["J.Ramirez", 1653], ["anandb", 1578], ["noarwhalmoo", 8173],
                ["Ethan Carpintero", 3157], ["511Slloth", 4699], ["BloodyBaron", 7383],
                ["HenryMcKeon3", 7649], ["jelly135", 15934], ["culobCoder", 30567],
                ["samson nwobi", 80921], ["LightningMc Code", 13198], ["LiquidKetchup", 1772],
                ["Declan Gibson", 2118], ["DaZe_sneenzy", 2377], ["Light in the Dark", 4114],
                ["K G", 1712], ["erand05", 5130], ["Angus MacGyver", 5916],
                ["CAMREN ALEXZANDER HUDSON", 8577], ["jedielijaho0", 125890], ["AnimTheTree", 5054],
                ["EmilyGRidenour", 7038], ["KikiNoelle", 1438], ["~The Mailbox Programmer~", 1355],
                ["Kochendorfer.Zackary", 40751], ["Wolf Studios", 4867], ["hmcknight01", 9685],
                ["Jeremy", 5008], ["elijah", 3998], ["Jay Rosa", 1756],
                ["Harrison P. Cevasco", 9127], ["Hotrod", 14567], ["A RANDOM GUY", 91094],
                ["Jo$h", 71234], ["Finder", 10919], ["Sye", 6407],
                ["Rohaam", 2268], ["CubsFan41", 2515], ["Benny", 13735],
                ["KingSwords", 9168], ["Alexander O.", 17030], ["Jilian", 196],
                ["Rebekah R.", 1243], ["Israel", 11532], ["Mr.JPrograms", 4851],
                ["AuttumStar", 929], ["Kingslay productions", 2113], ["₱ⱤØ₲Ɽ₳₥₥ł₦₲ ₭ł₦₲", 114898],
                ["👑👑👑Aidair Sanchez👑👑", 11657], ["T̵̢̹̤͑̌h̵̗̹̞͉̼̠̲̚ę̸̩̼̘̀̐͜͝n̴͎̼̜͙̜̻̾̑̋̔r̸͎̬̱̻͚̓̋̊͊͝y̵̫̓̉̑͗̈́", 5238],
                ["мя. Lємoиѕ", 2951], ["Duck Dino", 10679], ["benyaminaharon739", 109724],
                ["ツ🅷🅰🅲🅺🅴🆁 🅿🅾🅳", 1342], ["❄PopsicleBoi❄", 4187], ["𝕀ℕ🔰𝔽𝕀𝕃𝕋ℝ𝔸𝕋𝕀𝕆ℕ", 4340],
            ];
            const top10 = leaderboard.sort((a, b) => b[1] - a[1]).slice(0, 10);

            // --- Class Definitions ---

            /**
             * @class Player
             * Manages the ball's state, movement, and score.
             */
            class Player {
                constructor() {
                    this.begin = false;
                    this.mode = "play";
                    this.score = 0;
                    this.highscore = 0;
                    this.y = s.height * 0.4;
                    this.prevLev = 0;
                    this.level = 0;
                    this.current = 0;
                    this.goal = 15;
                    this.jump = -s.height * 0.015;
                    this.maxJump = s.height * 0.015;
                    this.Level = 1;
                    this.gameOver = false;
                    this.splatter = [];
                    this.fill = ball;
                    this.bounce = 0;
                }

                /**
                 * Draws the player ball on the canvas.
                 */
                display() {
                    s.push();
                    s.translate(0, s.height * 0.4 - s.height/2, 0); // Correct for WEBGL coordinate system
                    s.scale(1 + s.sin(s.radians(this.bounce)) / 5, 1 - s.sin(s.radians(this.bounce)) / 5);
                    
                    // Ball shadow (optional in 3D, could be a flat disc below)
                    // s.push();
                    // s.fill(s.color(0, 0, 0, 50));
                    // s.ellipse(s.width * 0.01, s.height * 0.01, s.width * 0.075, s.height * 0.05);
                    // s.pop();

                    // Main ball body
                    s.noStroke();
                    s.fill(this.fill);
                    s.sphere(s.width * 0.035);

                    s.pop();
                    
                    // Draw jump particles
                    for (let i = particles.length - 1; i >= 0; i--) {
                        let p = particles[i];
                        s.push();
                        s.fill(p.c, p.alpha);
                        s.noStroke();
                        s.translate(p.x - s.width/2, p.y - s.height/2, 0);
                        s.sphere(p.size);
                        s.pop();

                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += p.gravity;
                        p.alpha -= 5;
                        p.size -= 0.1;
                    }
                }

                /**
                 * Updates the player's position and jump state.
                 */
                update() {
                    this.jump = s.constrain(this.jump, -this.maxJump, this.maxJump);
                    this.y += this.jump;
                    this.jump += s.height * 0.001;
                    this.bounce -= (this.bounce - 0) / 4;
                    this.fill = s.lerpColor(this.fill, ball, 0.1);

                    if (this.mode === "endless") {
                        this.goal = this.level + 10;
                    }

                    if (this.y >= s.height * 0.4) {
                        this.y = s.height * 0.4;
                        for (let layer of layers) {
                            layer.l -= this.jump;
                        }
                        for (let splatter of this.splatter) {
                            splatter[1] -= this.jump;
                        }
                    }
                }

                /**
                 * Handles player scoring and level progression.
                 */
                displayScore() {
                    // Temporarily switch back to 2D for text drawing
                    s.push();
                    s.camera(); // Reset camera for 2D UI
                    s.textFont(CONFIG.fonts[0]);
                    s.textSize(s.width * 0.175);
                    s.textAlign(s.CENTER, s.CENTER);
                    s.fill(0);
                    s.text(this.score, 0, -s.height * 0.38);
                    s.fill(0, 100);
                    s.text(this.score, -s.width * 0.005, -s.height * 0.38 + s.height * 0.002);
                    s.pop();
                    this.highscore = s.max(this.score, this.highscore);
                }
            }

            /**
             * @class Layer
             * Represents a single platform layer of the helix.
             */
            class Layer {
                constructor(l) {
                    this.l = l;
                    this.angle = s.random(360);
                    this.num = s.floor(s.random(3, 7)); // 3 to 6 platforms
                    this.space = s.floor(s.random(this.num));
                    this.dis = s.floor(s.random(this.num));
                    this.dist = 360 / this.num;
                }

                /**
                 * Draws the layer and its platforms.
                 */
                display() {
                    if (!p) return; // Prevent error if p is not yet initialized

                    s.push();
                    s.translate(0, this.l - s.height/2, 0);
                    
                    // Pillar (3D)
                    s.push();
                    s.fill(central);
                    s.noStroke();
                    s.rotateX(s.HALF_PI);
                    s.cylinder(s.width * 0.035, s.height * 0.65, 16, 1);
                    s.pop();

                    // Platforms (3D)
                    for (let i = 0; i < this.num; i++) {
                        let ang = this.angle + this.dist * i;
                        if (i !== this.space && (i !== this.dis || p.mode === "endless")) {
                            s.push();
                            s.rotateY(s.radians(ang));
                            s.translate(0, 0, s.height * 0.22);
                            if (i === this.dis && p.mode === "endless") {
                                s.fill(255, 0, 50);
                            } else {
                                s.fill(platform);
                            }
                            s.noStroke();
                            s.box(s.width * 0.35, s.height * 0.04, s.width * 0.02);
                            s.pop();
                        }
                    }
                    s.pop();
                }

                /**
                 * Checks for collision with the player ball.
                 */
                checkCollision() {
                    const angle = p.y - this.l;
                    if (angle <= 0 && angle > p.jump && this.l < s.height * 0.5) {
                        for (let i = 0; i < this.num; i++) {
                            const platformAngle = (this.angle + this.dist * i + 360) % 360;
                            if (i !== this.space) {
                                if (platformAngle < 100 && platformAngle > 80) {
                                    if (i === this.dis && p.mode === "endless") {
                                        this.handleGameOver();
                                    } else {
                                        this.handleBounce();
                                    }
                                }
                            }
                        }
                    }
                }

                /**
                 * Handles the ball bouncing on a platform.
                 */
                handleBounce() {
                    p.jump = -s.height * 0.015;
                    p.prevLev = p.level;
                    p.level++;
                    p.current++;
                    p.bounce = 100;
                    for (let k = 0; k < 15; k++) {
                        particles.push(new Particle(s.width / 2, p.y, ball));
                    }
                    if (p.mode === "play" && p.current >= p.goal) {
                        p.current = 0;
                        p.Level++;
                        Cur_Pal++;
                        updatePalette(Cur_Pal);
                        for (let j = 0; j < 10; j++) {
                            ptsEarned.push([s.width / 2, -100, s.random(-10, 10), s.random(-10, -5), s.random(5, 10)]);
                        }
                    }
                }

                /**
                 * Initiates the game over sequence.
                 */
                handleGameOver() {
                    p.gameOver = true;
                    isGameOverAnimating = true;
                    shakeAmount = s.width * 0.025;
                    screenFlashAlpha = 200;
                    for (let k = 0; k < 50; k++) {
                        explosionParticles.push(new ExplosionParticle(s.width / 2, p.y, s.color(255, 0, 0)));
                    }
                }
            }

            /**
             * @class Particle
             * Manages particles for regular jumps.
             */
            class Particle {
                constructor(x, y, c) {
                    this.x = x;
                    this.y = y;
                    this.c = c;
                    this.vx = s.random(-2, 2);
                    this.vy = s.random(-5, -1);
                    this.size = s.random(2, 5);
                    this.alpha = 255;
                    this.gravity = 0.2;
                }
            }

            /**
             * @class ExplosionParticle
             * Manages particles for the game over explosion.
             */
            class ExplosionParticle {
                constructor(x, y, c) {
                    this.x = x;
                    this.y = y;
                    this.c = c;
                    this.vx = s.random(-5, 5);
                    this.vy = s.random(-10, 0);
                    this.size = s.random(5, 10);
                    this.alpha = 255;
                    this.gravity = 0.3;
                }
            }

            // --- Game Objects ---
            let p;

            // --- Utility Functions ---

            /**
             * Custom function to draw multi-line text with alignment.
             * @param {string} str - The text to draw.
             * @param {number} x - The x-coordinate.
             * @param {number} y - The y-coordinate.
             * @param {object} c - The color object.
             */
            const drawText = (str, x, y, c) => {
                if (c) {
                    s.fill(c);
                }
                const lines = str.split('\n');
                const lineHeight = (s.textSize() * 1.2);
                const totalHeight = lines.length * lineHeight;
                s.push();
                if (s.textAlign() === s.CENTER) {
                    s.translate(x, y - totalHeight / 2 + lineHeight / 2);
                    for (let i = 0; i < lines.length; i++) {
                        s.text(lines[i], 0, i * lineHeight);
                    }
                } else {
                    s.translate(x, y);
                    for (let i = 0; i < lines.length; i++) {
                        s.text(lines[i], 0, i * lineHeight);
                    }
                }
                s.pop();
            };

            /**
             * Updates the palette colors smoothly.
             * @param {number} index - The index of the new color palette.
             */
            const updatePalette = (index) => {
                if (index === undefined) {
                    index = Cur_Pal % (CONFIG.palettes.length);
                }
                targetCentral = CONFIG.palettes[index][0];
                targetPlatform = CONFIG.palettes[index][1];
                targetBg = CONFIG.palettes[index][2];
                targetBall = CONFIG.palettes[index][3];
                targetLava = CONFIG.palettes[index][4];
            };

            /**
             * Lerps the current colors towards the target colors.
             */
            const lerpColors = () => {
                central = s.lerpColor(central, targetCentral, 0.05);
                platform = s.lerpColor(platform, targetPlatform, 0.05);
                bg = s.lerpColor(bg, targetBg, 0.05);
                ball = s.lerpColor(ball, targetBall, 0.05);
                lava = s.lerpColor(lava, targetLava, 0.05);
            };

            /**
             * Initializes a new game.
             * @param {string} mode - "play" or "endless".
             */
            const startGame = (mode) => {
                p = new Player();
                p.mode = mode;
                layers = [];
                for (let i = 0; i < 6; i++) {
                    layers.push(new Layer(s.height * 0.3 - i * s.height * 0.25));
                }
                currentScene = SCENES.PLAY;
                updatePalette(2);
            };

            // --- Scene Functions ---

            /**
             * Displays the main menu scene.
             */
            const menuScene = () => {
                s.background(bg);
                s.directionalLight(255, 255, 255, -0.5, -1, -0.5);
                s.ambientLight(60);
                lerpColors();
                
                s.push();
                s.rotateX(s.map(s.mouseY, 0, s.height, -s.PI/8, s.PI/8));
                s.rotateY(s.map(s.mouseX, 0, s.width, -s.PI/8, s.PI/8));

                // Draw helix tower
                s.push();
                s.fill(central);
                s.noStroke();
                s.rotateX(s.HALF_PI);
                s.cylinder(s.width * 0.035, s.height * 0.65, 16, 1);
                s.pop();

                for (let layer of layers) {
                    layer.angle -= 60 * s.deltaTime / 1000;
                    s.push();
                    s.translate(0, layer.l - s.height/2, 0);
                    s.specularMaterial(platform);
                    for (let i = 0; i < layer.num; i++) {
                        let ang = layer.angle + layer.dist * i;
                        if (i !== layer.space) {
                            s.push();
                            s.rotateY(s.radians(ang));
                            s.translate(0, 0, s.height * 0.22);
                            s.box(s.width * 0.35, s.height * 0.04, s.width * 0.02);
                            s.pop();
                        }
                    }
                    s.pop();
                }

                p.update();
                p.display();

                s.pop();

                // Draw UI texts (in 2D space)
                s.camera();
                s.ortho();
                
                s.textFont(CONFIG.fonts[1]);
                s.textSize(s.width * 0.15);
                s.textAlign(s.CENTER, s.CENTER);
                drawText("Helix\nJump", s.width / 2, s.height * 0.2, s.color(50, 150, 250));

                if (p.score !== 0) {
                    s.textFont(CONFIG.fonts[0]);
                    s.textSize(s.width * 0.07);
                    drawText("YOUR SCORE: " + p.score + "\nBEST: " + p.highscore, s.width / 2, s.height * 0.4, s.color(50, 150, 250));
                }

                s.textFont(CONFIG.fonts[0]);
                s.textSize(s.width * 0.06);
                drawText("Level " + p.Level, s.width / 2, s.height * 0.5);

                // Draw buttons
                for (let i = 0; i < CONFIG.titles.length; i++) {
                    const y = s.height * 0.6 + i * s.height * 0.08;
                    const h = s.height * 0.06;
                    const w = s.width * 0.6;
                    const isHover = s.mouseX > s.width/2 - w/2 && s.mouseX < s.width/2 + w/2 &&
                                    s.mouseY > y - h/2 && s.mouseY < y + h/2;
                    s.push();
                    if (isHover) {
                        s.scale(1.05);
                        s.translate(0, 0, 1); // Bring forward slightly
                    }
                    s.fill(0, CONFIG.titles[i][1]);
                    s.noStroke();
                    s.rect(s.width / 2, y, w, h, s.width * 0.02);
                    s.pop();

                    s.push();
                    s.fill(255);
                    s.textFont(CONFIG.fonts[0]);
                    s.textSize(s.width * 0.06);
                    drawText(CONFIG.titles[i][0], s.width / 2, y);
                    s.pop();
                }
            };

            /**
             * Displays the main game scene.
             */
            const playScene = () => {
                s.background(bg);
                s.directionalLight(255, 255, 255, -0.5, -1, -0.5);
                s.ambientLight(60);
                lerpColors();

                // Apply screen shake effect
                if (shakeAmount > 0) {
                    s.translate(s.random(-shakeAmount, shakeAmount), s.random(-shakeAmount, shakeAmount));
                    shakeAmount *= 0.9;
                }
                
                s.push();
                s.camera();
                s.ortho();

                // Game Over animation and logic
                if (p.gameOver) {
                    // Draw explosion particles
                    for (let i = explosionParticles.length - 1; i >= 0; i--) {
                        let ep = explosionParticles[i];
                        s.push();
                        s.fill(ep.c, ep.alpha);
                        s.noStroke();
                        s.translate(ep.x - s.width/2, ep.y - s.height/2, 0);
                        s.sphere(ep.size);
                        s.pop();

                        ep.x += ep.vx;
                        ep.y += ep.vy;
                        ep.vy += ep.gravity;
                        ep.alpha -= 5;
                        ep.size -= 0.2;
                    }

                    // Screen flash effect
                    s.fill(255, 0, 0, screenFlashAlpha);
                    s.rect(s.width / 2, s.height / 2, s.width, s.height);
                    screenFlashAlpha = s.lerp(screenFlashAlpha, 0, 0.1);

                    // Fade out
                    s.fill(0, s.map(screenFlashAlpha, 200, 0, 0, 150));
                    s.rect(s.width/2, s.height/2, s.width, s.height);

                    // Display "Game Over" text
                    s.fill(255, s.map(screenFlashAlpha, 200, 0, 0, 255));
                    s.textFont(CONFIG.fonts[1]);
                    s.textSize(s.width * 0.2);
                    s.text("Game Over", s.width/2, s.height/2);

                    p.display();
                    p.displayScore();
                    s.pop();

                    // Check for end of animation to return to menu
                    if (explosionParticles.length === 0 && screenFlashAlpha < 1) {
                        currentScene = SCENES.MENU;
                        p.gameOver = false;
                    }
                } else {
                    // Regular game logic
                    p.update();
                    for (let i = layers.length - 1; i >= 0; i--) {
                        layers[i].l -= p.jump;
                        layers[i].checkCollision();
                        layers[i].display();
                    }
                    p.display();
                    p.displayScore();
                    s.pop();
                }
                particles = particles.filter(p => p.alpha > 0 && p.size > 0);
                explosionParticles = explosionParticles.filter(e => e.alpha > 0 && e.size > 0);
            };

            /**
             * Displays the leaderboard scene.
             */
            const leaderboardScene = () => {
                s.background(bg);
                lerpColors();
                
                s.push();
                s.camera();
                s.ortho();

                s.textFont(CONFIG.fonts[1]);
                s.textSize(s.width * 0.1);
                drawText("LEADERBOARD", s.width / 2, s.height * 0.1);

                s.textFont(CONFIG.fonts[0]);
                s.textSize(s.width * 0.045);
                s.textAlign(s.LEFT);
                for (let i = 0; i < top10.length; i++) {
                    s.text(`${i + 1}. ${top10[i][0]}`, s.width * 0.25, s.height * 0.2 + i * s.height * 0.05);
                    s.textAlign(s.RIGHT);
                    s.text(top10[i][1], s.width * 0.75, s.height * 0.2 + i * s.height * 0.05);
                    s.textAlign(s.LEFT);
                }
                s.textAlign(s.CENTER);

                // Back button
                s.fill(0, 100);
                s.noStroke();
                s.rect(s.width / 2, s.height * 0.9, s.width * 0.5, s.height * 0.08, s.width * 0.02);
                s.fill(255);
                s.textFont(CONFIG.fonts[0]);
                s.textSize(s.width * 0.06);
                drawText("BACK", s.width / 2, s.height * 0.9);
                s.pop();
            };

            /**
             * Displays the credits scene.
             */
            const creditsScene = () => {
                s.background(bg);
                lerpColors();
                
                s.push();
                s.camera();
                s.ortho();
                
                s.textFont(CONFIG.fonts[1]);
                s.textSize(s.width * 0.1);
                drawText("CREDITS", s.width / 2, s.height * 0.1);
                s.textFont(CONFIG.fonts[0]);
                s.textSize(s.width * 0.06);
                drawText("All Code by\n    ARROWHEAD CO.\n\nBased on\nHELIX JUMP by\n    VOODOO", s.width / 2, s.height * 0.4);

                // Back button
                s.fill(0, 100);
                s.noStroke();
                s.rect(s.width / 2, s.height * 0.9, s.width * 0.5, s.height * 0.08, s.width * 0.02);
                s.fill(255);
                s.textFont(CONFIG.fonts[0]);
                s.textSize(s.width * 0.06);
                drawText("BACK", s.width / 2, s.height * 0.9);
                s.pop();
            };

            // --- p5.js Core Functions ---

            s.setup = () => {
                s.createCanvas(s.windowWidth * 0.8, s.windowHeight * 0.8, s.WEBGL);
                s.rectMode(s.CENTER);
                s.textAlign(s.CENTER, s.CENTER);
                s.smooth();

                // Initial color setup
                central = CONFIG.palettes[2][0];
                platform = CONFIG.palettes[2][1];
                bg = CONFIG.palettes[2][2];
                ball = CONFIG.palettes[2][3];
                lava = CONFIG.palettes[2][4];

                targetCentral = central;
                targetPlatform = platform;
                targetBg = bg;
                targetBall = ball;
                targetLava = lava;

                p = new Player();
                for (let i = 0; i < 6; i++) {
                    layers.push(new Layer(s.height * 0.3 - i * s.height * 0.25));
                }
            };

            s.draw = () => {
                switch (currentScene) {
                    case SCENES.MENU:
                        menuScene();
                        break;
                    case SCENES.PLAY:
                        playScene();
                        break;
                    case SCENES.LEADERBOARD:
                        leaderboardScene();
                        break;
                    case SCENES.CREDITS:
                        creditsScene();
                        break;
                }
            };

            s.windowResized = () => {
                s.resizeCanvas(s.windowWidth * 0.8, s.windowHeight * 0.8);
                p.y = s.height * 0.4;
                p.jump = -s.height * 0.015;
                p.maxJump = s.height * 0.015;
                for (let layer of layers) {
                    layer.l = s.height * 0.3 - layers.indexOf(layer) * s.height * 0.25;
                }
            };
            
            // --- Input Handlers ---
            s.mouseClicked = () => {
                if (currentScene === SCENES.MENU) {
                    for (let i = 0; i < CONFIG.titles.length; i++) {
                        const y = s.height * 0.6 + i * s.height * 0.08;
                        const h = s.height * 0.06;
                        const w = s.width * 0.6;
                        if (s.mouseY > y - h/2 && s.mouseY < y + h/2 && s.mouseX > s.width/2 - w/2 && s.mouseX < s.width/2 + w/2) {
                            switch (i) {
                                case 0:
                                    startGame("endless");
                                    break;
                                case 1:
                                    startGame("play");
                                    break;
                                case 2:
                                    currentScene = SCENES.LEADERBOARD;
                                    break;
                                case 3:
                                    currentScene = SCENES.CREDITS;
                                    break;
                            }
                        }
                    }
                } else if (currentScene === SCENES.LEADERBOARD || currentScene === SCENES.CREDITS) {
                    // Back button logic
                    if (s.mouseY > s.height * 0.9 - s.height * 0.04 && s.mouseY < s.height * 0.9 + s.height * 0.04) {
                        if (s.mouseX > s.width * 0.5 - s.width * 0.25 && s.mouseX < s.width * 0.5 + s.width * 0.25) {
                            currentScene = SCENES.MENU;
                        }
                    }
                }
            };
            
            s.mouseDragged = () => {
                if (currentScene === SCENES.PLAY) {
                    let mouseDelta = s.mouseX - s.pmouseX;
                    for (let layer of layers) {
                        layer.angle += mouseDelta / s.width * 360;
                    }
                }
            };

            s.touchMoved = (event) => {
                if (currentScene === SCENES.PLAY) {
                    if (event.touches.length > 0) {
                        let touchX = event.touches[0].clientX;
                        let deltaX = touchX - lastTouchX;
                        for (let layer of layers) {
                            layer.angle += deltaX / s.width * 360;
                        }
                        lastTouchX = touchX;
                    }
                }
                return false; // Prevent default browser behavior
            };

            s.touchStarted = (event) => {
                if (currentScene === SCENES.PLAY) {
                    if (event.touches.length > 0) {
                        lastTouchX = event.touches[0].clientX;
                    }
                }
            };
            
            s.keyPressed = () => {
                if (currentScene === SCENES.PLAY) {
                    if (s.keyCode === s.RIGHT_ARROW) {
                        for (let layer of layers) {
                            layer.angle += 5;
                        }
                    } else if (s.keyCode === s.LEFT_ARROW) {
                        for (let layer of layers) {
                            layer.angle -= 5;
                        }
                    }
                }
            };

        });
    </script>
</body>
</html>
